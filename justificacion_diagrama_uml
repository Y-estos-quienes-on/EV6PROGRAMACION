Análisis del Diagrama de Clases
El diagrama representa cuatro entidades principales: Usuario, Administrador, Dispositivo y Automatizacion. 
•	Clase Usuario: Es la clase base, con atributos como usuario, email, contraseña y rol. Tiene métodos para el manejo de sesiones, datos personales y cambiar la contraseña. 
•	Clase Administrador: Esta clase hereda de Usuario, lo que indica que un Administrador es un tipo de Usuario. Agrega la funcionalidad específica de modificar_rol().
•	Clase General: También hereda de Usuario, representando un tipo de usuario estándar. En este diagrama, no se le añaden atributos o métodos específicos, pero su existencia establece una
jerarquía clara.
•	Clase Dispositivo: Contiene atributos como id, nombre, tipo y estado. Posee métodos para interactuar con el dispositivo (encender(), apagar(), mostrar_estado()).
•	Clase Automatizacion: Define reglas con nombre, condiciones y acciones. Su método principal es ejecutar().
Justificación de Relaciones y Principios POO
1. Herencia
El diagrama muestra que las clases Administrador y General heredan de la clase Usuario. Este principio permite la reutilización de código y el establecimiento de una jerarquía lógica.
Ambas subclases (Administrador y General) adquieren automáticamente los atributos (usuario, email, contraseña, rol) y métodos (registrar(), iniciar_sesion(), consultar_datos()) de la 
superclase Usuario. Esto evita la duplicidad de código y facilita el mantenimiento. Un administrador es un tipo de usuario, lo que hace que esta relación sea intuitiva y eficiente.
2. Encapsulamiento
Los atributos de las clases, como -usuario: str  están marcados con un guion (-), lo que en la notación UML indica que son privados. Los métodos, marcados con un más (+), son públicos. 
Este es el principio de encapsulamiento. Los datos internos de un objeto están protegidos y solo se pueden modificar a través de los métodos públicos definidos para la clase. 
Esto asegura que el estado del objeto sea siempre consistente y controlado, evitando manipulaciones directas e inesperadas. Por ejemplo, para cambiar el estado de un dispositivo, se debe
usar el método encender() o apagar(), lo que puede incluir lógicas de validación.
3. Agregación
La relación entre Usuario y Dispositivo está marcada con un rombo vacío (-◇), que representa una agregación. La agregación indica una relación de "posee un" o "contiene", donde el objeto
"parte" puede existir de forma independiente del objeto "todo". En este caso, un Usuario posee varios Dispositivos (1..*), pero un Dispositivo puede existir sin ser propiedad de un 
Usuario (por ejemplo, antes de ser configurado o si se transfiere a otro usuario). La vida de un dispositivo no depende de la vida del usuario.
4. Composición
La relación entre Dispositivo y Automatizacion está marcada con un rombo sólido (-◆), que representa una composición. La composición es un tipo de agregación más fuerte. 
Indica que el objeto "parte" no puede existir sin el objeto "todo". Una Automatizacion es una parte de un Dispositivo; no tiene sentido que una regla de automatización exista por sí 
sola si no está asociada a un dispositivo específico. Si se elimina un Dispositivo, todas las Automatizaciones asociadas a él deben ser eliminadas también, ya que dependen directamente 
de él.

